var documenterSearchIndex = {"docs":
[{"location":"#LMDiskANN","page":"Home","title":"LMDiskANN","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"LM-DiskANN is an approximate nearest‐neighbor indexing library that builds and maintains a disk‐resident graph structure for high‐dimensional data. It aims to provide a balance between fast search times, memory efficiency, and support for incremental updates (insertion and deletion). Under the hood, LM-DiskANN stores vector embeddings in memory‐mapped files, limiting in‐memory usage while preserving quick random access. It also leverages a graph-based BFS expansion to find candidate neighbors, with user‐configurable parameters like search expansion factor (EF_SEARCH) and maximum neighborhood size (maxdegree).","category":"page"},{"location":"","page":"Home","title":"Home","text":"\"LM-diskann: Low memory footprint in disk-native dynamic graph-based ann indexing.\" Pan, Yu, Jianxin Sun, and Hongfeng Yu, 2023 IEEE International Conference on Big Data (BigData). IEEE, 2023.","category":"page"},{"location":"","page":"Home","title":"Home","text":"It offers the optional user‐key mapping, allowing users to associate string keys with each embedding. This means you can insert vectors with a custom ID (e.g., \"image001\"), search for nearest neighbors, then retrieve or delete by either the numeric internal ID or the user key. The library includes utility functions to open, close, and clear these user‐key databases, enabling a more flexible integration with real-world applications where data might be identified by strings or external IDs.","category":"page"},{"location":"#Example-Usage-with-Synthetic-Data","page":"Home","title":"Example Usage with Synthetic Data","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Below is a short script you can run to see LM-DiskANN in action. We’ll:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Create an index for dim=5 vectors.\nInsert a few vectors—some with user keys, some without.\nSearch for a known vector.\nDelete by either numeric ID or user key.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using LMDiskANN  \nusing Random\n\n# 1 make an index with dimension 5\ndim = 5\nindex = create_index(\"example_index\", dim)\n\n# 2 insert a couple of random vectors\nvec1 = rand(Float32, 5)\n(key1, id1) = ann_insert!(index, vec1)\n@show key1, id1   # e.g. might be (\"1\", 1) if no user key was specified\n\n# insert a vector with a user key\nvec2 = rand(Float32, 5)\n(user_key, id2) = ann_insert!(index, vec2; key=\"my_special_vector\")\n@show user_key, id2  # e.g. (\"my_special_vector\", 2)\n\n# 3 search for vec1\nresults = search(index, vec1, topk=3)  # returns an array of (maybeKey, ID)\nprintln(\"Search results for vec1 = \", results)\n\n# 4 retrieve the actual embedding from the index by numeric ID\nretrieved_vec1 = get_embedding_from_id(index, id1)\nprintln(\"retrieved_vec1 == vec1 ? \", all(retrieved_vec1 .== vec1))\n\n# retrieve by user key\nretrieved_vec2 = get_embedding_from_key(index, \"my_special_vector\")\nprintln(\"retrieved_vec2 == vec2 ? \", all(retrieved_vec2 .== vec2))\n\n# 5 delete an entry\nann_delete!(index, id1) # by numeric ID\nann_delete!(index, \"my_special_vector\") # by user key\n\n# 6 confirm they're gone (search or retrieval should fail)\nprintln(\"After deletions, search(vec1) => \", search(index, vec1, topk=3))\ntry\n    get_embedding_from_id(index, id1)\ncatch e\n    println(\"Caught an expected error when retrieving a deleted vector: \", e)\nend","category":"page"},{"location":"#Example-real-data-embeddings-from-GLoVe-and-usage","page":"Home","title":"Example real data embeddings from GLoVe and usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Build a 10 000-word cosine LM-DiskANN index and explore semantic neighbours using embedding vectors from GLoVe.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Embeddings #downloads pre-trained vectors of word embeddings\nusing LMDiskANN #this package added via, add https://github.com/mantzaris/LMDiskANN.jl\nusing Distances, LinearAlgebra, Random, Printf\n\ntab = load_embeddings(GloVe{:en}, 2; max_vocab_size = 10_000)\nwords = tab.vocab\nvectors = tab.embeddings #100 × 10 000 Float32\n(dim, N) = size(vectors)\n@info \"Loaded $N by $dim GloVe vectors\"\n\nword2id = Dict(w => i for (i, w) in enumerate(words)) #helper function\nvectors ./= sqrt.(sum(abs2, vectors; dims = 1)) #normalisation\n\nidx = create_index(\"glove_demo\", dim; metric = CosineDist()) #<- create the store\n\nfor (vec, w) in zip(eachcol(vectors), words)  #insert into the lmdiskann the (vector, word)\n    ann_insert!(idx, vec; key = w) #<- insert into the store\nend\n@info \"Index built with $(idx.num_points) points\"\n\n\nnearest(w; k = 5) = let id = word2id[w]\n    hits = search(idx, vectors[:, id], topk = k + 1) #<- search the store, first high result would be the word itself\n    [words[h[2]] for h in hits[2:end]]\nend\n\nfor w in (\"king\", \"queen\", \"paris\", \"cat\", \"coffee\")\n           @printf(\"  %-6s -> %s\\n\", w, join(nearest(w), \", \"))\n       end\n# prints eg:\n#  king   -> prince, queen, son, brother, monarch\n#  queen  -> princess, king, elizabeth, royal, lady\n#  paris  -> france, london, brussels, french, rome\n#  cat    -> dog, cats, pet, dogs, mouse\n#  coffee -> tea, drinks, beer, wine, drink\n\n#classic analogy for vectors\n\nv = vectors[:, word2id[\"king\"]] .- vectors[:, word2id[\"man\"]] .+ vectors[:, word2id[\"woman\"]]\nv ./= norm(v) \n\n\nignore = Set([\"king\", \"man\", \"woman\"]) #skip seed words\nfor (_key, id) in search(idx, v, topk = 10)\n    w = words[id]\n    w ∉ ignore && (println(\"king - man + woman -> \", w); break)\nend\n\n#prints:\n# king - man + woman -> queen","category":"page"},{"location":"","page":"Home","title":"Home","text":"Documentation for LMDiskANN.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#LMDiskANN.ann_delete!-Union{Tuple{T}, Tuple{LMDiskANN.LMDiskANNIndex{T}, Union{Int64, String}}} where T<:AbstractFloat","page":"Home","title":"LMDiskANN.ann_delete!","text":"ann_delete!(index::LMDiskANNIndex{T}, node_id::Union{Int,String}) where {T<:AbstractFloat}\n\nDelete a vector (and adjacency) from the index. Implements Algorithm 3 from the LM-DiskANN paper.\n\nArguments\n\nindex::LMDiskANNIndex: The index to delete from\nnode_id::Int: The ID of the vector to delete\n\nReturns\n\nLMDiskANNIndex: The updated index instance\n\nExample\n\nLMDiskANN.ann_delete!(index, id)\n\n\n\n\n\n","category":"method"},{"location":"#LMDiskANN.ann_insert!-Union{Tuple{T}, Tuple{LMDiskANN.LMDiskANNIndex{T}, AbstractVector{<:AbstractFloat}}} where T<:AbstractFloat","page":"Home","title":"LMDiskANN.ann_insert!","text":"ann_insert!(index::LMDiskANNIndex{T},\n                 new_vec::AbstractVector{<:AbstractFloat};\n                 key::Union{Nothing,String}=nothing) where {T<:AbstractFloat}\n\nInsert a new vector into the index. Updates the adjacency structure. Returns the assigned ID of the newly inserted vector. Implements Algorithm 2 from the LM-DiskANN paper.\n\nArguments\n\nindex::LMDiskANNIndex{T}: The index to insert into\nnew_vec::Vector{<:AbstractFloat}: The vector to insert\n\nOptional Arguments\n\nkey:: String: the key the user wants to associate with the new vector\n\nReturns\n\n(key,Int): The tuple of the key (string) and ID (int) assigned to the inserted vector\n\nExample\n\n(key,id) = LMDiskANN.ann_insert!(index, vector)\n\n\n\n\n\n","category":"method"},{"location":"#LMDiskANN.clear_all_databases!-Tuple{Any, Any}","page":"Home","title":"LMDiskANN.clear_all_databases!","text":"clear_all_databases!(db_forward, db_reverse)\n\nRemoves all entries from both forward and reverse databases.\n\nArguments\n\ndb_forward: Forward mapping database handle\ndb_reverse: Reverse mapping database handle\n\n\n\n\n\n","category":"method"},{"location":"#LMDiskANN.close_databases-Tuple{Any, Any}","page":"Home","title":"LMDiskANN.close_databases","text":"close_databases(db_forward, db_reverse)\n\nCloses both databases.\n\n\n\n\n\n","category":"method"},{"location":"#LMDiskANN.close_id_mapping-Union{Tuple{LMDiskANN.LMDiskANNIndex{T}}, Tuple{T}} where T<:AbstractFloat","page":"Home","title":"LMDiskANN.close_id_mapping","text":"close_id_mapping(index::LMDiskANNIndex{T})\n\nCloses the user-key DB if open.\n\n\n\n\n\n","category":"method"},{"location":"#LMDiskANN.create_index-Tuple{String, Int64}","page":"Home","title":"LMDiskANN.create_index","text":"create_index(path_prefix::String, dim::Int; T::Type=Float32, maxdegree::Int=DEFAULT_MAX_DEGREE, metric::PreMetric=Euclidean())\n\nCreates a brand new LM-DiskANN index on disk with the given dimension, storing to files: path_prefix.vec, path_prefix.adj, path_prefix.meta.\n\nArguments\n\npath_prefix::String: Prefix for the index files (without extension)\ndim::Int: Dimensionality of the vectors to be indexed\n\nOptional arguments\n\n= T::Type=Float32: the typer for the embedding vectors\n\nmaxdegree::Int=DEFAULT_MAX_DEGREE: Maximum number of neighbors per node\nmetric::PreMetric which is default Euclidean but can be a metric from Distances.jl\n\nReturns\n\nLMDiskANNIndex: A new index instance\n\nExample\n\nindex = LMDiskANN.create_index(\"my_index\", 128)\n\n\n\n\n\n","category":"method"},{"location":"#LMDiskANN.delete_by_id!-Tuple{Any, Any, Int64}","page":"Home","title":"LMDiskANN.delete_by_id!","text":"delete_by_id!(db_forward, db_reverse, internal_id::Int)\n\nDeletes the entry for internal_id in db_reverse, and also deletes the corresponding entry in db_forward.\n\n\n\n\n\n","category":"method"},{"location":"#LMDiskANN.delete_by_key!-Tuple{Any, Any, String}","page":"Home","title":"LMDiskANN.delete_by_key!","text":"delete_by_key!(db_forward, db_reverse, user_key::String)\n\nDeletes the entry for user_key in db_forward, and also deletes the corresponding entry in db_reverse.\n\n\n\n\n\n","category":"method"},{"location":"#LMDiskANN.get_embedding_from_id-Union{Tuple{T}, Tuple{LMDiskANN.LMDiskANNIndex{T}, Int64}} where T<:AbstractFloat","page":"Home","title":"LMDiskANN.get_embedding_from_id","text":"get_embedding_from_id(index::LMDiskANNIndex{T}, id::Int)::Vector{T} where {T<:AbstractFloat}\n\nGiven a 1-based ID (the same ID you'd see returned by ann_insert! or in search), retrieve the stored embedding vector from index.vecs.\n\nThrows an error if id is out of range or if it's already deleted (i.e., in the freelist).\n\n\n\n\n\n","category":"method"},{"location":"#LMDiskANN.get_embedding_from_key-Union{Tuple{T}, Tuple{LMDiskANN.LMDiskANNIndex{T}, String}} where T<:AbstractFloat","page":"Home","title":"LMDiskANN.get_embedding_from_key","text":"get_embedding_from_key(index::LMDiskANNIndex{T}, key::String)::Vector{T} where {T<:AbstractFloat}\n\nARgument is a string key (which was stored during ann_insert!(..., key=...)), look up the 1-based ID from the forward DB, then retrieve the embedding.\n\nThrows an error if the key doesn't exist\n\n\n\n\n\n","category":"method"},{"location":"#LMDiskANN.get_id_from_key-Tuple{Any, String}","page":"Home","title":"LMDiskANN.get_id_from_key","text":"get_id_from_key(db_forward, user_key::String) -> Union{Int, Nothing}\n\nFetches the internalid associated with `userkeyfromdb_forward. Returnsnothing` if not found.\n\n\n\n\n\n","category":"method"},{"location":"#LMDiskANN.get_key_from_id-Tuple{Any, Int64}","page":"Home","title":"LMDiskANN.get_key_from_id","text":"get_key_from_id(db_reverse, internal_id::Int) -> Union{String, Nothing}\n\nFetches the userkey from `dbreversegiven the internal_id. Returnsnothing` if not found.\n\n\n\n\n\n","category":"method"},{"location":"#LMDiskANN.insert_key!-Tuple{Any, Any, String, Int64}","page":"Home","title":"LMDiskANN.insert_key!","text":"insert_key!(db_forward, db_reverse, user_key::String, internal_id::Int)\n\nInserts user_key -> internal_id into db_forward, and internal_id -> user_key into db_reverse.\n\nBoth must be done to keep them in sync.\n\n\n\n\n\n","category":"method"},{"location":"#LMDiskANN.list_all_keys-Tuple{Any}","page":"Home","title":"LMDiskANN.list_all_keys","text":"list_all_keys(db) -> Vector{String}\n\nReturns a list of all keys in the database as strings.\n\nArguments\n\ndb: LevelDB database handle\n\nReturns\n\nVector{String}: List of all keys in the database\n\n\n\n\n\n","category":"method"},{"location":"#LMDiskANN.load_index-Tuple{String}","page":"Home","title":"LMDiskANN.load_index","text":"load_index(path_prefix::String; metric::PreMetric=Euclidean())\n\nLoads an existing index,  eltype and the original metric are read from the meta-file automatically. You can also specify the metric which is by default Euclidean from Distances.jl\n\n\n\n\n\n","category":"method"},{"location":"#LMDiskANN.open_databases-Tuple{String, String}","page":"Home","title":"LMDiskANN.open_databases","text":"open_databases(forward_path::String, reverse_path::String; create_if_missing=true)\n\nOpens (or creates) two LevelDB databases:\n\ndbforward: stringkey -> stringofinternal_id\ndbreverse: stringofinternalid -> string_key\n\nReturns a tuple (dbforward, dbreverse).\n\n\n\n\n\n","category":"method"},{"location":"#LMDiskANN.search-Union{Tuple{T}, Tuple{LMDiskANN.LMDiskANNIndex{T}, AbstractVector{<:AbstractFloat}}} where T<:AbstractFloat","page":"Home","title":"LMDiskANN.search","text":"search(index::LMDiskANNIndex{T},\n            query_vec::AbstractVector{<:AbstractFloat};\n            topk::Int=10) where {T<:AbstractFloat}\n\nReturns top-k approximate nearest neighbors for query_vec.\n\nArguments\n\nindex::LMDiskANNIndex: The index to search\nquery_vec::AbstractVector{Float32}: The query vector\ntopk::Int=10: Number of nearest neighbors to return\nef::Int=DEFAULT_EF_SEARCH (size of the candidate list explored during the graph, larger ef means higher recall but slower queries) and ef is automatically promoted to at least topk.\n\nReturns\n\nVector{Tuple{Union{String,Nothing}, Int}} : a list of (key, id) pairs for the top-k nearest neighbours\n\nExample\n\nresults = LMDiskANN.search(index, query_vec, topk=5)\n\n\n\n\n\n","category":"method"}]
}
